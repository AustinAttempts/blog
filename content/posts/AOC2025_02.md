---
date: '2025-12-01T14:12:56-08:00'
draft: false
title: 'AOC 2025 Day 2: Gift Shop'
author: ["Austin Guevara"]
type: "post"
---

For prior days please check out my [Advent of Code 2025]({{<relref "posts/AOC2025.md" >}}) Overview post. To see my final solution for this puzzle go [here](https://github.com/AustinAttempts/AOC2025/blob/main/Day_02/main.zig).

## Puzzle
After yesterdays [Day 1: Secret Entrance]({{<relref "posts/AOC2025_01.md" >}}) solution we now have access to the North Pole.  Once we enter we notice that the Gift Shop is having issues becuase an elf was playing around and added invalid IDs to the database.  In order to save the day we must go through the database (Puzzle input) and find all invalid product IDs.

The Puzzle input will look like this:

```
11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124
```

## Part 1

An Invalid ID is any ID that is made up of two identical sequences of numbers. For example, ```55``` because it is made up of ```5``` twice, or ```123123``` because it is made up of ```123``` twice.

<img src="/imgs/AOC2025_02/Part1_example.png#center" alt="Valid vs Invalid ID">

We must first parse each ID range which is ```,``` seperated. Then, check the *inclusive* range for any invalid IDs. Adding all the invalid IDs up will give the solution to the puzzle. Doing this on the above example would look like:

```
11-22 -> 11 & 22
95-115 -> 99
998-1012 -> 1010
1188511880-1188511890 -> 1188511885
222220-222224 -> 222222
1698522-1698528 -> (all valid IDs)
446443-446449 -> 446446
38593856-38593862 -> 38593859
565653-565659 -> (all valid IDs)
824824821-824824827 -> (all valid IDs)
2121212118-2121212124 -> (all valid IDs)
```

final answer: ```1227775554```

## Part 1 Solution

When doing similar LeetCode problems I learned that anytime you are looking for patterns it is much easier to do all the logic on a string rather than a number. This means that when I loop through the range of IDs I need to take the extra step to conver the value ```n``` to ```"n"``` (i.e. ```123123``` becomes ```"123123"```).  This becomes especially true because Zig allows the use of string slices.

My thought process was to split each ID string into 2 halfs.  If those halfs are equal then it's an invalid ID.

### Parsing Input Data

This will be very similar each day.  If you are confused refrence my [Day 01]({{<relref "posts/AOC2025_01.md" >}}) solution for a more detailed explanation.

```zig
 var id_ranges = std.mem.splitScalar(u8, input, ',');
 while (id_ranges.next()) |id_range| {
        var bounds = std.mem.splitScalar(u8, id_range, '-');
        const start_id = try std.fmt.parseInt(usize, bounds.next().?, 10);
        const end_id = try td.fmt.parseInt(usize, bounds.next().?, 10);

        for (start_id..end_id + 1) |id| {
            const id_str = try std.fmt.bufPrint(&buf, "{d}", .{id});
            // Check if ID is Valid or Invalid
        }
    }

```

### Checking IDs
```zig
pub fn bad_id(id: []const u8) bool {
    const len = id.len;
    const first_half = id[0 .. len / 2];
    const second_half = id[len / 2 .. len];
    if (std.mem.eql(u8, first_half, second_half)) {
        return true;
    }

    return false;
}
```

### Solution
```zig
pub fn part1(input: []const u8) !usize {
    var bad_id_sum: usize = 0;
    var id_ranges = std.mem.splitScalar(u8, input, ',');
    var buf: [32]u8 = undefined; // Attempt to remove allocations

    while (id_ranges.next()) |id_range| {
        var bounds = std.mem.splitScalar(u8, id_range, '-');
        const start_id = try std.fmt.parseInt(usize, bounds.next().?, 10);
        const end_id = try std.fmt.parseInt(usize, bounds.next().?, 10);

        for (start_id..end_id + 1) |id| {
            const id_str = try std.fmt.bufPrint(&buf, "{d}", .{id});
            if (bad_id(id_str)) {
                bad_id_sum += id;
            }
        }
    }

    return bad_id_sum;
}

pub fn bad_id(id: []const u8) bool {
    const len = id.len;
    const first_half = id[0 .. len / 2];
    const second_half = id[len / 2 .. len];
    if (std.mem.eql(u8, first_half, second_half)) {
        return true;
    }

    return false;
}
```

